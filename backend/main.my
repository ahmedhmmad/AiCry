from fastapi import FastAPI, HTTPException, Query
from sqlalchemy import create_engine, text
import redis
import os
import pandas as pd
import numpy as np
from dotenv import load_dotenv
from datetime import datetime
from indicators import calculate_macd, generate_sample_data, comprehensive_analysis, calculate_rsi
from binance_client import BinanceClient, extract_close_prices
from alert_service import AlertService
from simple_ai import simple_ai
from advanced_ai import advanced_ai
from typing import List, Optional, Dict, Any
from pydantic import BaseModel

# إضافة try/except للوحدات الاختيارية
try:
    from enhanced_trading_signals import EnhancedTradingSignals, analyze_timeframe_consensus
    ENHANCED_SIGNALS_AVAILABLE = True
except ImportError:
    print("⚠️ Enhanced trading signals module not found - using basic analysis only")
    ENHANCED_SIGNALS_AVAILABLE = False
    EnhancedTradingSignals = None
    analyze_timeframe_consensus = None

try:
    from wyckoff_analysis import WyckoffIntegration
    WYCKOFF_AVAILABLE = True
except ImportError:
    print("⚠️ Wyckoff analysis module not found - skipping Wyckoff features")
    WYCKOFF_AVAILABLE = False
    WyckoffIntegration = None

load_dotenv()

app = FastAPI(title="Trading AI Platform", version="1.0.0")

# Database connection
DATABASE_URL = "postgresql://trading_user:trading_pass_2024@postgres:5432/trading_db"
engine = create_engine(DATABASE_URL)

# Redis connection
redis_client = redis.Redis(host='redis', port=6379, decode_responses=True)

# Binance client
binance_client = BinanceClient()

# Enhanced trading client (only if available)
enhanced_signals = None
if ENHANCED_SIGNALS_AVAILABLE:
    try:
        enhanced_signals = EnhancedTradingSignals(binance_client)
        print("✅ Enhanced trading signals initialized successfully")
    except Exception as e:
        print(f"⚠️ Failed to initialize enhanced trading signals: {e}")
        ENHANCED_SIGNALS_AVAILABLE = False

# Wyckoff integration (only if available)
wyckoff_integration = None
if WYCKOFF_AVAILABLE:
    try:
        wyckoff_integration = WyckoffIntegration(binance_client)
        print("✅ Wyckoff analysis initialized successfully")
    except Exception as e:
        print(f"⚠️ Failed to initialize Wyckoff analysis: {e}")
        WYCKOFF_AVAILABLE = False

# Alert service
alert_service = AlertService(DATABASE_URL)

def clean_response_data(data):
    """تنظيف البيانات من numpy types قبل إرسالها"""
    if isinstance(data, dict):
        return {k: clean_response_data(v) for k, v in data.items()}
    elif isinstance(data, list):
        return [clean_response_data(item) for item in data]
    elif isinstance(data, (np.integer, np.int64, np.int32)):
        return int(data)
    elif isinstance(data, (np.floating, np.float64, np.float32)):
        return float(data)
    elif isinstance(data, np.ndarray):
        return data.tolist()
    elif pd.isna(data):
        return None
    return data

@app.get("/")
async def root():
    features = [
        "Real-time data from Binance",
        "MACD Technical Analysis",
        "Multiple cryptocurrency support",
        "AI-powered predictions"
    ]

    if ENHANCED_SIGNALS_AVAILABLE:
        features.append("Enhanced trading signals with volume analysis")
    if WYCKOFF_AVAILABLE:
        features.append("Wyckoff market cycle analysis")

    return {
        "message": "Trading AI Platform API",
        "status": "running",
        "features": features,
        "modules_status": {
            "enhanced_signals": ENHANCED_SIGNALS_AVAILABLE,
            "wyckoff_analysis": WYCKOFF_AVAILABLE
        }
    }

@app.get("/health")
async def health_check():
    try:
        with engine.connect() as conn:
            result = conn.execute(text("SELECT 1"))
            db_status = "connected"
    except Exception as e:
        db_status = f"error: {str(e)}"

    try:
        redis_client.ping()
        redis_status = "connected"
    except Exception as e:
        redis_status = f"error: {str(e)}"

    try:
        price = binance_client.get_symbol_price("BTCUSDT")
        binance_status = "connected" if price else "error"
    except Exception as e:
        binance_status = f"error: {str(e)}"

    return {
        "database": db_status,
        "redis": redis_status,
        "binance_api": binance_status,
        "api": "healthy",
        "modules": {
            "enhanced_signals": ENHANCED_SIGNALS_AVAILABLE,
            "wyckoff_analysis": WYCKOFF_AVAILABLE
        }
    }

@app.get("/ai/ultimate-analysis/{symbol}")
async def get_ultimate_analysis(
    symbol: str,
    interval: str = Query(default="1h", description="Analysis timeframe"),
    include_wyckoff: bool = Query(default=True, description="Include Wyckoff analysis")
):
    """
    التحليل الشامل النهائي مع جميع طبقات الذكاء الصناعي
    """
    try:
        klines_data = binance_client.get_klines(symbol, interval, 200)
        if not klines_data:
            raise HTTPException(status_code=404, detail=f"Could not fetch data for {symbol}")

        close_prices = extract_close_prices(klines_data)
        volumes = [item['volume'] for item in klines_data]
        latest_candle = klines_data[-1]

        # التحليل الفني التقليدي
        technical_analysis = comprehensive_analysis(close_prices)

        # AI البسيط
        simple_ai_result = {"error": "Model not trained"}
        try:
            if simple_ai.is_trained or simple_ai.load_model():
                simple_ai_result = simple_ai.predict(close_prices)
        except Exception as e:
            simple_ai_result = {"error": f"خطأ في AI البسيط: {str(e)}"}

        # AI المتقدم
        advanced_ai_result = {"error": "Model not trained"}
        try:
            if advanced_ai.is_trained or advanced_ai.load_ensemble():
                advanced_ai_result = advanced_ai.predict_ensemble(close_prices, volumes)
        except Exception as e:
            advanced_ai_result = {"error": f"خطأ في AI المتقدم: {str(e)}"}

        # تحليل وايكوف (إذا كان متاحاً ومطلوباً)
        wyckoff_result = {"error": "Wyckoff module not available"}
        if WYCKOFF_AVAILABLE and include_wyckoff and wyckoff_integration:
            try:
                wyckoff_result = wyckoff_integration.get_wyckoff_analysis_for_symbol(symbol, interval)
            except Exception as e:
                wyckoff_result = {"error": f"خطأ في تحليل وايكوف: {str(e)}"}

        # القرار النهائي المدمج
        ultimate_decision = combine_recommendations(
            technical_analysis, simple_ai_result, advanced_ai_result, wyckoff_result
        )

        # بناء النتيجة النهائية
        result = {
            "symbol": symbol.upper(),
            "current_price": float(latest_candle["close"]),
            "timestamp": pd.Timestamp.fromtimestamp(latest_candle["timestamp"]/1000).strftime("%Y-%m-%d %H:%M:%S UTC"),
            "analysis_layers": {
                "1_technical_analysis": technical_analysis,
                "2_simple_ai": simple_ai_result,
                "3_advanced_ai": advanced_ai_result
            },
            "ultimate_decision": ultimate_decision,
            "analysis_summary": {
                "total_analysis_methods": 3 + (1 if WYCKOFF_AVAILABLE and include_wyckoff and "error" not in wyckoff_result else 0),
                "confidence_score": float(ultimate_decision.get("final_confidence", 0)),
                "risk_assessment": ultimate_decision.get("risk_level", "UNKNOWN"),
                "recommendation_strength": ultimate_decision.get("strength", "WEAK")
            }
        }

        # إضافة تحليل وايكوف إذا كان متاحاً
        if WYCKOFF_AVAILABLE and include_wyckoff and "error" not in wyckoff_result:
            result["analysis_layers"]["4_wyckoff_analysis"] = wyckoff_result

        # تنظيف البيانات من numpy types قبل الإرسال
        cleaned_result = clean_response_data(result)
        return clean_response_data(response)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/price/{symbol}")
async def get_symbol_price(symbol: str):
    """
    الحصول على السعر الحالي للعملة مع معلومات إضافية
    """
    try:
        # جلب السعر الحالي
        current_price = binance_client.get_symbol_price(symbol)
        if not current_price:
            raise HTTPException(status_code=404, detail=f"Symbol {symbol} not found")

        # جلب بيانات إضافية للتحليل
        klines_data = binance_client.get_klines(symbol, "1h", 25)  # 24 ساعة + الحالية

        price_info = {
            "symbol": symbol.upper(),
            "price": float(current_price),
            "timestamp": datetime.utcnow().isoformat(),
            "currency": "USDT"
        }

        if klines_data and len(klines_data) >= 2:
            # حساب التغيير في الـ 24 ساعة
            current = float(klines_data[-1]["close"])
            previous_24h = float(klines_data[-25]["close"]) if len(klines_data) >= 25 else float(klines_data[0]["close"])

            price_change = current - previous_24h
            price_change_percent = (price_change / previous_24h) * 100

            # حساب أعلى وأدنى سعر في 24 ساعة
            highs = [float(candle["high"]) for candle in klines_data[-24:]]
            lows = [float(candle["low"]) for candle in klines_data[-24:]]
            volumes = [float(candle["volume"]) for candle in klines_data[-24:]]

            price_info.update({
                "change_24h": round(price_change, 4),
                "change_percent_24h": round(price_change_percent, 2),
                "high_24h": max(highs) if highs else current,
                "low_24h": min(lows) if lows else current,
                "volume_24h": sum(volumes) if volumes else 0,
                "market_status": determine_market_status(price_change_percent)
            })

        return clean_response_data(price_info)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/symbols")
async def get_available_symbols():
    """
    الحصول على قائمة العملات المتاحة
    """
    try:
        symbols = binance_client.get_available_symbols()
        return {
            "symbols": symbols,
            "count": len(symbols),
            "note": "Popular USDT trading pairs"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/market/overview")
async def get_market_overview():
    """نظرة عامة على السوق"""
    try:
        major_symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT", "XRPUSDT"]
        market_data = {}
        total_positive = 0
        total_symbols = 0

        for symbol in major_symbols:
            try:
                current_price = binance_client.get_symbol_price(symbol)
                if current_price:
                    klines = binance_client.get_klines(symbol, "1d", 2)
                    if klines and len(klines) >= 2:
                        current = float(klines[-1]["close"])
                        previous = float(klines[-2]["close"])
                        change_24h = ((current - previous) / previous) * 100

                        market_data[symbol] = {
                            "symbol": symbol,
                            "price": float(current_price),
                            "change_24h": round(change_24h, 2),
                            "volume": float(klines[-1]["volume"]),
                            "status": "UP" if change_24h > 0 else "DOWN" if change_24h < 0 else "NEUTRAL"
                        }

                        if change_24h > 0:
                            total_positive += 1
                        total_symbols += 1
            except Exception as e:
                continue

        # حساب المعنويات
        positive_ratio = total_positive / total_symbols if total_symbols > 0 else 0

        if positive_ratio > 0.7:
            market_sentiment = "VERY_BULLISH"
        elif positive_ratio > 0.5:
            market_sentiment = "BULLISH"
        elif positive_ratio > 0.3:
            market_sentiment = "NEUTRAL"
        else:
            market_sentiment = "BEARISH"

        overview = {
            "market_sentiment": market_sentiment,
            "positive_ratio": round(positive_ratio * 100, 1),
            "total_symbols_analyzed": total_symbols,
            "symbols_up": total_positive,
            "symbols_down": total_symbols - total_positive,
            "market_data": market_data,
            "last_updated": datetime.utcnow().isoformat()
        }

        return clean_response_data(overview)

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Helper functions
def calculate_price_change_24h(klines_data):
    """حساب تغيير السعر في 24 ساعة"""
    try:
        if len(klines_data) >= 25:
            current = float(klines_data[-1]["close"])
            previous = float(klines_data[-25]["close"])
            return round(((current - previous) / previous) * 100, 2)
        return 0
    except:
        return 0

def calculate_high_24h(klines_data):
    """حساب أعلى سعر في 24 ساعة"""
    try:
        if len(klines_data) >= 24:
            highs = [float(candle["high"]) for candle in klines_data[-24:]]
            return max(highs)
        return float(klines_data[-1]["high"]) if klines_data else 0
    except:
        return 0

def calculate_low_24h(klines_data):
    """حساب أدنى سعر في 24 ساعة"""
    try:
        if len(klines_data) >= 24:
            lows = [float(candle["low"]) for candle in klines_data[-24:]]
            return min(lows)
        return float(klines_data[-1]["low"]) if klines_data else 0
    except:
        return 0

def calculate_volume_24h(klines_data):
    """حساب حجم التداول في 24 ساعة"""
    try:
        if len(klines_data) >= 24:
            volumes = [float(candle["volume"]) for candle in klines_data[-24:]]
            return sum(volumes)
        return float(klines_data[-1]["volume"]) if klines_data else 0
    except:
        return 0

def determine_market_status(change_percent):
    """تحديد حالة السوق"""
    if change_percent > 5:
        return "STRONG_BULLISH"
    elif change_percent > 2:
        return "BULLISH"
    elif change_percent > -2:
        return "NEUTRAL"
    elif change_percent > -5:
        return "BEARISH"
    else:
        return "STRONG_BEARISH"

# Help endpoint for Enhanced Signals (only if available)
if ENHANCED_SIGNALS_AVAILABLE:
    @app.get("/trading/signals/help")
    async def get_enhanced_signals_help():
        """
        دليل استخدام نظام الإشارات المحسن
        """
        return {
            "title": "Enhanced Trading Signals System v1.0",
            "description": "نظام إشارات التداول المحسن مع تحليل متقدم ومؤشرات ذكية",
            "status": "Available",
            "endpoints": {
                "enhanced_signals": {
                    "url": "/trading/signals/enhanced/{symbol}",
                    "description": "الحصول على إشارات تداول محسنة مع تحليل متقدم",
                    "parameters": {
                        "symbol": "رمز العملة (مثل BTCUSDT)",
                        "timeframe": "الإطار الزمني (1m, 5m, 15m, 1h, 4h, 1d)",
                        "signal_strength": "قوة الإشارة (strong, medium, weak, all)"
                    },
                    "example": "/trading/signals/enhanced/BTCUSDT?timeframe=1h&signal_strength=strong"
                },
                "compare_signals": {
                    "url": "/trading/signals/compare/{symbol}",
                    "description": "مقارنة الإشارات عبر أطر زمنية متعددة",
                    "parameters": {
                        "symbol": "رمز العملة",
                        "timeframes": "أطر زمنية مفصولة بفاصلة"
                    },
                    "example": "/trading/signals/compare/ETHUSDT?timeframes=1h,4h,1d"
                },
                "signals_summary": {
                    "url": "/trading/signals/summary/{symbol}",
                    "description": "ملخص سريع للإشارات - مناسب للداشبورد",
                    "example": "/trading/signals/summary/BTCUSDT?timeframe=1h"
                },
                "watchlist_signals": {
                    "url": "/trading/signals/watchlist",
                    "description": "إشارات قائمة المراقبة لعدة عملات",
                    "parameters": {
                        "symbols": "قائمة العملات مفصولة بفاصلة",
                        "timeframe": "الإطار الزمني",
                        "min_confidence": "الحد الأدنى للثقة"
                    },
                    "example": "/trading/signals/watchlist?symbols=BTCUSDT,ETHUSDT&min_confidence=70"
                }
            },
            "features": [
                "Enhanced RSI signals with volume confirmation",
                "Advanced MACD analysis with histogram trends",
                "Bollinger Bands squeeze detection for breakouts",
                "Golden Cross and Death Cross identification",
                "High volume breakout and breakdown detection",
                "AI model predictions integration",
                "Multi-timeframe consensus analysis",
                "Market context and risk assessment",
                "Confidence-weighted signal aggregation",
                "Watchlist monitoring for multiple symbols"
            ]
        }
else:
    @app.get("/trading/signals/help")
    async def get_enhanced_signals_help():
        """
        معلومات حول نظام الإشارات المحسن (غير متاح)
        """
        return {
            "title": "Enhanced Trading Signals System",
            "status": "Not Available",
            "message": "Enhanced trading signals module is not installed or configured",
            "available_alternatives": [
                "/analysis/{symbol} - للتحليل الشامل التقليدي",
                "/ai/ultimate-analysis/{symbol} - للتحليل بالذكاء الصناعي",
                "/price/{symbol} - للسعر الحالي والمعلومات الأساسية"
            ],
            "note": "لتفعيل نظام الإشارات المحسن، تأكد من وجود ملف enhanced_trading_signals.py"
        }

# API Documentation endpoint
@app.get("/docs/api")
async def get_api_documentation():
    """
    دليل استخدام API
    """
    return {
        "title": "Trading AI Platform API Documentation",
        "version": "1.0.0",
        "description": "منصة التداول بالذكاء الصناعي - دليل المطور",

        "modules_status": {
            "enhanced_signals": ENHANCED_SIGNALS_AVAILABLE,
            "wyckoff_analysis": WYCKOFF_AVAILABLE,
            "basic_analysis": True,
            "ai_predictions": True
        },

        "core_endpoints": {
            "health_check": {
                "url": "/health",
                "method": "GET",
                "description": "فحص حالة النظام والاتصالات"
            },
            "symbol_price": {
                "url": "/price/{symbol}",
                "method": "GET",
                "description": "السعر الحالي مع تفاصيل السوق"
            },
            "comprehensive_analysis": {
                "url": "/analysis/{symbol}",
                "method": "GET",
                "description": "التحليل الفني الشامل",
                "parameters": ["symbol", "interval", "limit"]
            },
            "ultimate_ai_analysis": {
                "url": "/ai/ultimate-analysis/{symbol}",
                "method": "GET",
                "description": "التحليل الشامل بجميع طبقات الذكاء الصناعي",
                "parameters": ["symbol", "interval", "include_wyckoff"]
            },
            "market_overview": {
                "url": "/market/overview",
                "method": "GET",
                "description": "نظرة عامة على السوق"
            },
            "available_symbols": {
                "url": "/symbols",
                "method": "GET",
                "description": "قائمة العملات المتاحة للتداول"
            }
        },

        "enhanced_endpoints": {
            "available": ENHANCED_SIGNALS_AVAILABLE,
            "endpoints": [
                "/trading/signals/enhanced/{symbol}",
                "/trading/signals/compare/{symbol}",
                "/trading/signals/summary/{symbol}",
                "/trading/signals/watchlist",
                "/trading/signals/help"
            ] if ENHANCED_SIGNALS_AVAILABLE else [],
            "note": "Enhanced signals require enhanced_trading_signals module"
        },

        "wyckoff_endpoints": {
            "available": WYCKOFF_AVAILABLE,
            "endpoints": [
                "/analysis/wyckoff/{symbol}"
            ] if WYCKOFF_AVAILABLE else [],
            "note": "Wyckoff analysis requires wyckoff_analysis module"
        },

        "supported_symbols": [
            "BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT", "XRPUSDT",
            "DOTUSDT", "LINKUSDT", "LTCUSDT", "BCHUSDT", "XLMUSDT"
        ],

        "supported_timeframes": [
            "1m", "5m", "15m", "30m", "1h", "4h", "6h", "12h", "1d"
        ],

        "response_format": {
            "success": {
                "status_code": 200,
                "data_type": "JSON",
                "cleaned": "All numpy types converted to native Python types"
            },
            "error": {
                "status_code": "4xx/5xx",
                "format": {"detail": "error message"}
            }
        },

        "usage_examples": {
            "get_btc_analysis": "GET /analysis/BTCUSDT?interval=1h",
            "get_enhanced_signals": "GET /trading/signals/enhanced/ETHUSDT?timeframe=4h&signal_strength=strong",
            "compare_timeframes": "GET /trading/signals/compare/BTCUSDT?timeframes=1h,4h,1d",
            "market_watchlist": "GET /trading/signals/watchlist?symbols=BTCUSDT,ETHUSDT&min_confidence=70",
            "wyckoff_analysis": "GET /analysis/wyckoff/BTCUSDT?multi_timeframe=true"
        },

        "rate_limits": {
            "binance_api": "Depends on Binance limits",
            "internal_processing": "No specific limits",
            "recommendation": "Use caching for frequent requests"
        }
    }

if __name__ == "__main__":
    import uvicorn
    print("🚀 Starting Trading AI Platform...")
    print(f"✅ Enhanced Signals: {'Available' if ENHANCED_SIGNALS_AVAILABLE else 'Not Available'}")
    print(f"✅ Wyckoff Analysis: {'Available' if WYCKOFF_AVAILABLE else 'Not Available'}")
    print("📊 Basic Analysis: Available")
    print("🤖 AI Predictions: Available")
    print("🌐 Server starting on http://0.0.0.0:8000")
    uvicorn.run(app, host="0.0.0.0", port=8000)ed_result

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"خطأ في التحليل الشامل: {str(e)}")

def combine_recommendations(technical: Dict, simple_ai: Dict, advanced_ai: Dict, wyckoff: Dict = None) -> Dict[str, Any]:
    """
    دمج التوصيات من جميع طبقات التحليل
    """
    try:
        # استخراج التوصيات والثقة من كل طبقة
        tech_rec = technical.get("overall_recommendation", "HOLD")
        tech_conf = float(technical.get("confidence", 50))

        simple_rec = "HOLD"
        simple_conf = 50.0
        if "recommendation" in simple_ai and "error" not in simple_ai:
            simple_rec = simple_ai["recommendation"]
            simple_conf = float(simple_ai.get("confidence", 50))

        advanced_rec = "HOLD"
        advanced_conf = 50.0
        if "ensemble_prediction" in advanced_ai and "error" not in advanced_ai:
            adv_pred = advanced_ai["ensemble_prediction"]
            advanced_rec = adv_pred.get("recommendation", "HOLD")
            advanced_conf = float(adv_pred.get("confidence", 50))

        # استخراج توصية وايكوف
        wyckoff_rec = "HOLD"
        wyckoff_conf = 50.0
        wyckoff_phase = "UNKNOWN"

        if wyckoff and "error" not in wyckoff and "trading_recommendation" in wyckoff:
            wyckoff_trading = wyckoff["trading_recommendation"]
            wyckoff_rec = wyckoff_trading.get("action", "HOLD")
            wyckoff_conf = float(wyckoff_trading.get("confidence", 50)) * 100  # تحويل إلى نسبة مئوية
            wyckoff_phase = wyckoff.get("current_phase", "UNKNOWN")

        # حساب الأوزان بناءً على الثقة
        total_weight = 0
        weighted_buy_score = 0
        weighted_sell_score = 0
        contributing_signals = 0

        # وزن التحليل الفني
        tech_weight = tech_conf / 100
        if tech_rec in ['BUY', 'STRONG_BUY']:
            weighted_buy_score += tech_weight
        elif tech_rec in ['SELL', 'STRONG_SELL']:
            weighted_sell_score += tech_weight
        total_weight += tech_weight
        if tech_rec != 'HOLD':
            contributing_signals += 1

        # وزن AI البسيط
        simple_weight = simple_conf / 100 * 1.2  # وزن أعلى للـ AI
        if simple_rec in ['BUY', 'STRONG_BUY']:
            weighted_buy_score += simple_weight
        elif simple_rec in ['SELL', 'STRONG_SELL']:
            weighted_sell_score += simple_weight
        total_weight += simple_weight
        if simple_rec != 'HOLD':
            contributing_signals += 1

        # وزن AI المتقدم
        advanced_weight = advanced_conf / 100 * 1.5  # أعلى وزن للـ AI المتقدم
        if advanced_rec in ['BUY', 'STRONG_BUY']:
            weighted_buy_score += advanced_weight
        elif advanced_rec in ['SELL', 'STRONG_SELL']:
            weighted_sell_score += advanced_weight
        total_weight += advanced_weight
        if advanced_rec != 'HOLD':
            contributing_signals += 1

        # وزن وايكوف (إذا كان متاحاً)
        wyckoff_weight = 0
        if wyckoff and "error" not in wyckoff:
            wyckoff_weight = wyckoff_conf / 100 * 1.3  # وزن عالي لتحليل وايكوف
            if wyckoff_rec in ['BUY', 'STRONG_BUY']:
                weighted_buy_score += wyckoff_weight
            elif wyckoff_rec in ['SELL', 'STRONG_SELL']:
                weighted_sell_score += wyckoff_weight
            total_weight += wyckoff_weight
            if wyckoff_rec != 'HOLD':
                contributing_signals += 1

        # حساب التوصية النهائية
        if total_weight == 0:
            final_recommendation = "HOLD"
            final_confidence = 50.0
            agreement_level = "NO_SIGNALS"
        else:
            buy_ratio = weighted_buy_score / total_weight
            sell_ratio = weighted_sell_score / total_weight

            if buy_ratio > sell_ratio and buy_ratio > 0.4:
                final_recommendation = "STRONG_BUY" if buy_ratio > 0.7 else "BUY"
                final_confidence = min(buy_ratio * 100 * 1.2, 95.0)
            elif sell_ratio > buy_ratio and sell_ratio > 0.4:
                final_recommendation = "STRONG_SELL" if sell_ratio > 0.7 else "SELL"
                final_confidence = min(sell_ratio * 100 * 1.2, 95.0)
            else:
                final_recommendation = "HOLD"
                final_confidence = 60.0

            # مستوى الاتفاق
            if contributing_signals >= 3:
                agreement_level = "STRONG_CONSENSUS"
            elif contributing_signals >= 2:
                agreement_level = "MODERATE_CONSENSUS"
            elif contributing_signals == 1:
                agreement_level = "SINGLE_SIGNAL"
            else:
                agreement_level = "MIXED_SIGNALS"

        # تحديد قوة التوصية
        if final_confidence > 80:
            strength = "VERY_STRONG"
        elif final_confidence > 65:
            strength = "STRONG"
        elif final_confidence > 50:
            strength = "MODERATE"
        else:
            strength = "WEAK"

        # تحديد مستوى المخاطر
        if final_confidence > 75 and contributing_signals >= 2:
            risk_level = "LOW"
        elif final_confidence > 60:
            risk_level = "MODERATE"
        else:
            risk_level = "HIGH"

        # إنشاء التفسير
        if contributing_signals == 0:
            reasoning = "لا توجد إشارات واضحة - من الأفضل الانتظار"
        elif contributing_signals == 1:
            reasoning = f"إشارة واحدة تشير إلى {final_recommendation}"
        else:
            consensus_type = "قوي" if agreement_level == "STRONG_CONSENSUS" else "متوسط" if agreement_level == "MODERATE_CONSENSUS" else "جزئي"
            reasoning = f"إجماع {consensus_type} من {contributing_signals} تحليل على {final_recommendation}"

        # إضافة معلومات وايكوف إذا كانت متاحة
        wyckoff_info = {}
        if wyckoff and "error" not in wyckoff:
            wyckoff_info = {
                "wyckoff_phase": wyckoff_phase,
                "wyckoff_recommendation": wyckoff_rec,
                "wyckoff_confidence": wyckoff_conf
            }

        return {
            "final_recommendation": final_recommendation,
            "final_confidence": round(final_confidence, 1),
            "reasoning": reasoning,
            "agreement_level": agreement_level,
            "risk_level": risk_level,
            "strength": strength,
            "contributing_signals": contributing_signals,
            "weight_distribution": {
                "technical": round(tech_weight / max(total_weight, 1), 1) if total_weight > 0 else 0,
                "simple_ai": round(simple_weight / max(total_weight, 1), 1) if total_weight > 0 else 0,
                "advanced_ai": round(advanced_weight / max(total_weight, 1), 1) if total_weight > 0 else 0,
                "wyckoff": round(wyckoff_weight / max(total_weight, 1), 1) if total_weight > 0 and wyckoff_weight > 0 else 0
            },
            **wyckoff_info
        }

    except Exception as e:
        return {
            "final_recommendation": "HOLD",
            "final_confidence": 50.0,
            "reasoning": f"خطأ في دمج التوصيات: {str(e)}",
            "agreement_level": "ERROR",
            "risk_level": "HIGH",
            "strength": "WEAK",
            "contributing_signals": 0,
            "error": str(e)
        }

# Enhanced Trading Signals Endpoints (only if module is available)
if ENHANCED_SIGNALS_AVAILABLE and enhanced_signals:

    @app.get("/trading/signals/enhanced/{symbol}")
    async def get_enhanced_trading_signals(
        symbol: str,
        timeframe: str = Query(default="1h", description="1m, 5m, 15m, 1h, 4h, 1d"),
        signal_strength: str = Query(default="all", description="strong, medium, weak, all")
    ):
        """
        الحصول على إشارات التداول المحسنة مع تحليل متقدم
        """
        try:
            result = enhanced_signals.get_enhanced_trading_signals(
                symbol=symbol.upper(),
                timeframe=timeframe,
                signal_strength=signal_strength
            )

            if "error" in result:
                raise HTTPException(status_code=400, detail=result["error"])

            return clean_response_data(result)

        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

    @app.get("/trading/signals/compare/{symbol}")
    async def compare_trading_signals(
        symbol: str,
        timeframes: str = Query(default="1h,4h,1d", description="Comma-separated timeframes")
    ):
        """
        مقارنة الإشارات عبر أطر زمنية متعددة للحصول على رؤية شاملة
        """
        try:
            timeframe_list = [tf.strip() for tf in timeframes.split(",")]
            comparison_results = {}

            for tf in timeframe_list:
                try:
                    result = enhanced_signals.get_enhanced_trading_signals(
                        symbol=symbol.upper(),
                        timeframe=tf,
                        signal_strength="medium"
                    )
                    comparison_results[tf] = result
                except Exception as e:
                    comparison_results[tf] = {"error": str(e)}

            # تحليل التوافق بين الأطر الزمنية
            consensus_analysis = analyze_timeframe_consensus(comparison_results)

            return clean_response_data({
                "symbol": symbol.upper(),
                "timeframe_analysis": comparison_results,
                "consensus": consensus_analysis,
                "generated_at": datetime.utcnow().isoformat()
            })

        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/trading/signals/summary/{symbol}")
    async def get_signals_summary(
        symbol: str,
        timeframe: str = Query(default="1h", description="Primary timeframe for analysis")
    ):
        """
        ملخص سريع للإشارات - للاستخدام في الداشبورد
        """
        try:
            result = enhanced_signals.get_enhanced_trading_signals(
                symbol=symbol.upper(),
                timeframe=timeframe,
                signal_strength="medium"
            )

            if "error" in result:
                raise HTTPException(status_code=400, detail=result["error"])

            # استخراج الملخص
            overall = result.get("overall_assessment", {})
            market_ctx = result.get("market_context", {})
            signals = result.get("signals", [])

            # إحصائيات سريعة
            signal_types = {}
            for signal in signals:
                signal_type = signal.get("type", "UNKNOWN")
                if signal_type not in signal_types:
                    signal_types[signal_type] = 0
                signal_types[signal_type] += 1

            summary = {
                "symbol": symbol.upper(),
                "current_price": result.get("current_price", 0),
                "overall_signal": overall.get("overall_signal", "HOLD"),
                "confidence": overall.get("confidence", 50),
                "trend": market_ctx.get("trend", "SIDEWAYS"),
                "risk_level": market_ctx.get("risk_level", "MEDIUM"),
                "price_change_24h": market_ctx.get("price_change_24h", 0),
                "signal_counts": signal_types,
                "total_signals": len(signals),
                "strongest_signal": overall.get("strongest_signal", {}),
                "recommendation": overall.get("recommendation", "No clear signals"),
                "last_updated": result.get("timestamp")
            }

            return clean_response_data(summary)

        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/trading/signals/watchlist")
    async def get_watchlist_signals(
        symbols: str = Query(default="BTCUSDT,ETHUSDT,BNBUSDT,ADAUSDT,XRPUSDT",
                            description="Comma-separated list of symbols"),
        timeframe: str = Query(default="1h", description="Timeframe for analysis"),
        min_confidence: int = Query(default=70, description="Minimum confidence level")
    ):
        """
        الحصول على إشارات قائمة المراقبة لعدة عملات
        """
        try:
            symbol_list = [s.strip().upper() for s in symbols.split(",")]
            watchlist_signals = {}

            for symbol in symbol_list:
                try:
                    result = enhanced_signals.get_enhanced_trading_signals(
                        symbol=symbol,
                        timeframe=timeframe,
                        signal_strength="medium"
                    )

                    if "error" not in result:
                        overall = result.get("overall_assessment", {})
                        confidence = overall.get("confidence", 0)

                        # تصفية حسب الحد الأدنى للثقة
                        if confidence >= min_confidence:
                            watchlist_signals[symbol] = {
                                "signal": overall.get("overall_signal", "HOLD"),
                                "confidence": confidence,
                                "current_price": result.get("current_price", 0),
                                "trend": result.get("market_context", {}).get("trend", "SIDEWAYS"),
                                "signal_count": result.get("signal_count", 0),
                                "strongest_signal": overall.get("strongest_signal", {}).get("indicator", "NONE")
                            }

                except Exception as e:
                    watchlist_signals[symbol] = {"error": str(e)}

            # ترتيب حسب الثقة
            sorted_signals = dict(sorted(
                watchlist_signals.items(),
                key=lambda x: x[1].get("confidence", 0) if "error" not in x[1] else 0,
                reverse=True
            ))

            # إحصائيات عامة
            valid_signals = {k: v for k, v in sorted_signals.items() if "error" not in v}
            buy_count = sum(1 for v in valid_signals.values() if v.get("signal") == "BUY")
            sell_count = sum(1 for v in valid_signals.values() if v.get("signal") == "SELL")

            return clean_response_data({
                "watchlist": sorted_signals,
                "summary": {
                    "total_symbols": len(symbol_list),
                    "signals_found": len(valid_signals),
                    "buy_signals": buy_count,
                    "sell_signals": sell_count,
                    "hold_signals": len(valid_signals) - buy_count - sell_count,
                    "min_confidence": min_confidence,
                    "timeframe": timeframe
                },
                "generated_at": datetime.utcnow().isoformat()
            })

        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

# Wyckoff Analysis Endpoints (only if module is available)
if WYCKOFF_AVAILABLE and wyckoff_integration:

    @app.get("/analysis/wyckoff/{symbol}")
    async def get_wyckoff_analysis(
        symbol: str,
        interval: str = Query(default="1h", description="Timeframe for analysis"),
        multi_timeframe: bool = Query(default=False, description="Multi-timeframe analysis")
    ):
        """
        تحليل وايكوف الشامل
        """
        try:
            if multi_timeframe:
                result = wyckoff_integration.get_multi_timeframe_wyckoff(symbol)
            else:
                result = wyckoff_integration.get_wyckoff_analysis_for_symbol(symbol, interval)

            if "error" in result:
                raise HTTPException(status_code=400, detail=result["error"])

            return clean_response_data(result)

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"خطأ في تحليل وايكوف: {str(e)}")

@app.get("/analysis/{symbol}")
async def get_comprehensive_analysis(
    symbol: str,
    interval: str = Query(default="1h", description="Timeframe: 1m, 5m, 15m, 1h, 4h, 1d"),
    limit: int = Query(default=200, ge=100, le=500, description="Number of data points")
):
    """
    الحصول على التحليل الشامل للعملة
    """
    try:
        # جلب البيانات من Binance
        klines_data = binance_client.get_klines(symbol, interval, limit)
        if not klines_data:
            raise HTTPException(status_code=404, detail=f"Could not fetch data for {symbol}")

        # استخراج الأسعار
        close_prices = extract_close_prices(klines_data)

        # التحليل الشامل باستخدام النظام الحالي
        analysis_result = comprehensive_analysis(close_prices)

        # الحصول على آخر شمعة
        latest_candle = klines_data[-1]

        # إضافة تحليل محسن إذا كان متوفراً
        enhanced_analysis = {}
        if ENHANCED_SIGNALS_AVAILABLE and enhanced_signals:
            try:
                enhanced_result = enhanced_signals.get_enhanced_trading_signals(
                    symbol=symbol.upper(),
                    timeframe=interval,
                    signal_strength="all"
                )
                if "error" not in enhanced_result:
                    enhanced_analysis = {
                        "enhanced_signals": enhanced_result.get("signals", []),
                        "market_context": enhanced_result.get("market_context", {}),
                        "overall_assessment": enhanced_result.get("overall_assessment", {})
                    }
            except Exception as e:
                print(f"Enhanced analysis failed: {e}")

        response = {
            "symbol": symbol.upper(),
            "interval": interval,
            "data_points": len(close_prices),
            "current_price": latest_candle["close"],
            "volume": latest_candle["volume"],
            "last_update": pd.Timestamp.fromtimestamp(latest_candle["timestamp"]/1000).strftime("%Y-%m-%d %H:%M:%S UTC"),
            "comprehensive_analysis": clean_response_data(analysis_result),
            "enhanced_analysis": clean_response_data(enhanced_analysis),
            "price_change_24h": calculate_price_change_24h(klines_data),
            "high_24h": calculate_high_24h(klines_data),
            "low_24h": calculate_low_24h(klines_data),
            "volume_24h": calculate_volume_24h(klines_data)
        }

        return clean
