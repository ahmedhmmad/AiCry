from fastapi import FastAPI, HTTPException, Query
from sqlalchemy import create_engine, text
import redis
import os
import pandas as pd
import numpy as np
from dotenv import load_dotenv
from datetime import datetime
from indicators import calculate_macd, generate_sample_data, comprehensive_analysis, calculate_rsi
from binance_client import BinanceClient, extract_close_prices
from alert_service import AlertService
from simple_ai import simple_ai
from advanced_ai import advanced_ai
from typing import List, Optional, Dict, Any
from pydantic import BaseModel

# Ø¥Ø¶Ø§ÙØ© try/except Ù„Ù„ÙˆØ­Ø¯Ø§Øª Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±ÙŠØ©
try:
    from enhanced_trading_signals import EnhancedTradingSignals, analyze_timeframe_consensus
    ENHANCED_SIGNALS_AVAILABLE = True
except ImportError:
    print("âš ï¸ Enhanced trading signals module not found - using basic analysis only")
    ENHANCED_SIGNALS_AVAILABLE = False
    EnhancedTradingSignals = None
    analyze_timeframe_consensus = None

try:
    from wyckoff_analysis import WyckoffIntegration
    WYCKOFF_AVAILABLE = True
except ImportError:
    print("âš ï¸ Wyckoff analysis module not found - skipping Wyckoff features")
    WYCKOFF_AVAILABLE = False
    WyckoffIntegration = None

load_dotenv()

app = FastAPI(title="Trading AI Platform", version="1.0.0")

# Database connection
DATABASE_URL = "postgresql://trading_user:trading_pass_2024@postgres:5432/trading_db"
engine = create_engine(DATABASE_URL)

# Redis connection
redis_client = redis.Redis(host='redis', port=6379, decode_responses=True)

# Binance client
binance_client = BinanceClient()

# Enhanced trading client (only if available)
enhanced_signals = None
if ENHANCED_SIGNALS_AVAILABLE:
    try:
        enhanced_signals = EnhancedTradingSignals(binance_client)
        print("âœ… Enhanced trading signals initialized successfully")
    except Exception as e:
        print(f"âš ï¸ Failed to initialize enhanced trading signals: {e}")
        ENHANCED_SIGNALS_AVAILABLE = False

# Wyckoff integration (only if available)
wyckoff_integration = None
if WYCKOFF_AVAILABLE:
    try:
        wyckoff_integration = WyckoffIntegration(binance_client)
        print("âœ… Wyckoff analysis initialized successfully")
    except Exception as e:
        print(f"âš ï¸ Failed to initialize Wyckoff analysis: {e}")
        WYCKOFF_AVAILABLE = False

# Alert service
alert_service = AlertService(DATABASE_URL)

def clean_response_data(data):
    """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† numpy types Ù‚Ø¨Ù„ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§"""
    if isinstance(data, dict):
        return {k: clean_response_data(v) for k, v in data.items()}
    elif isinstance(data, list):
        return [clean_response_data(item) for item in data]
    elif isinstance(data, (np.integer, np.int64, np.int32)):
        return int(data)
    elif isinstance(data, (np.floating, np.float64, np.float32)):
        return float(data)
    elif isinstance(data, np.ndarray):
        return data.tolist()
    elif pd.isna(data):
        return None
    return data

@app.get("/")
async def root():
    features = [
        "Real-time data from Binance",
        "MACD Technical Analysis",
        "Multiple cryptocurrency support",
        "AI-powered predictions"
    ]

    if ENHANCED_SIGNALS_AVAILABLE:
        features.append("Enhanced trading signals with volume analysis")
    if WYCKOFF_AVAILABLE:
        features.append("Wyckoff market cycle analysis")

    return {
        "message": "Trading AI Platform API",
        "status": "running",
        "features": features,
        "modules_status": {
            "enhanced_signals": ENHANCED_SIGNALS_AVAILABLE,
            "wyckoff_analysis": WYCKOFF_AVAILABLE
        }
    }

@app.get("/health")
async def health_check():
    try:
        with engine.connect() as conn:
            result = conn.execute(text("SELECT 1"))
            db_status = "connected"
    except Exception as e:
        db_status = f"error: {str(e)}"

    try:
        redis_client.ping()
        redis_status = "connected"
    except Exception as e:
        redis_status = f"error: {str(e)}"

    try:
        price = binance_client.get_symbol_price("BTCUSDT")
        binance_status = "connected" if price else "error"
    except Exception as e:
        binance_status = f"error: {str(e)}"

    return {
        "database": db_status,
        "redis": redis_status,
        "binance_api": binance_status,
        "api": "healthy",
        "modules": {
            "enhanced_signals": ENHANCED_SIGNALS_AVAILABLE,
            "wyckoff_analysis": WYCKOFF_AVAILABLE
        }
    }

@app.get("/ai/ultimate-analysis/{symbol}")
async def get_ultimate_analysis(
    symbol: str,
    interval: str = Query(default="1h", description="Analysis timeframe"),
    include_wyckoff: bool = Query(default=True, description="Include Wyckoff analysis")
):
    """
    Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ
    """
    try:
        klines_data = binance_client.get_klines(symbol, interval, 200)
        if not klines_data:
            raise HTTPException(status_code=404, detail=f"Could not fetch data for {symbol}")

        close_prices = extract_close_prices(klines_data)
        volumes = [item['volume'] for item in klines_data]
        latest_candle = klines_data[-1]

        # Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠ
        technical_analysis = comprehensive_analysis(close_prices)

        # AI Ø§Ù„Ø¨Ø³ÙŠØ·
        simple_ai_result = {"error": "Model not trained"}
        try:
            if simple_ai.is_trained or simple_ai.load_model():
                simple_ai_result = simple_ai.predict(close_prices)
        except Exception as e:
            simple_ai_result = {"error": f"Ø®Ø·Ø£ ÙÙŠ AI Ø§Ù„Ø¨Ø³ÙŠØ·: {str(e)}"}

        # AI Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        advanced_ai_result = {"error": "Model not trained"}
        try:
            if advanced_ai.is_trained or advanced_ai.load_ensemble():
                advanced_ai_result = advanced_ai.predict_ensemble(close_prices, volumes)
        except Exception as e:
            advanced_ai_result = {"error": f"Ø®Ø·Ø£ ÙÙŠ AI Ø§Ù„Ù…ØªÙ‚Ø¯Ù…: {str(e)}"}

        # ØªØ­Ù„ÙŠÙ„ ÙˆØ§ÙŠÙƒÙˆÙ (Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ø§Ù‹ ÙˆÙ…Ø·Ù„ÙˆØ¨Ø§Ù‹)
        wyckoff_result = {"error": "Wyckoff module not available"}
        if WYCKOFF_AVAILABLE and include_wyckoff and wyckoff_integration:
            try:
                wyckoff_result = wyckoff_integration.get_wyckoff_analysis_for_symbol(symbol, interval)
            except Exception as e:
                wyckoff_result = {"error": f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ ÙˆØ§ÙŠÙƒÙˆÙ: {str(e)}"}

        # Ø§Ù„Ù‚Ø±Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø§Ù„Ù…Ø¯Ù…Ø¬
        ultimate_decision = combine_recommendations(
            technical_analysis, simple_ai_result, advanced_ai_result, wyckoff_result
        )

        # Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
        result = {
            "symbol": symbol.upper(),
            "current_price": float(latest_candle["close"]),
            "timestamp": pd.Timestamp.fromtimestamp(latest_candle["timestamp"]/1000).strftime("%Y-%m-%d %H:%M:%S UTC"),
            "analysis_layers": {
                "1_technical_analysis": technical_analysis,
                "2_simple_ai": simple_ai_result,
                "3_advanced_ai": advanced_ai_result
            },
            "ultimate_decision": ultimate_decision,
            "analysis_summary": {
                "total_analysis_methods": 3 + (1 if WYCKOFF_AVAILABLE and include_wyckoff and "error" not in wyckoff_result else 0),
                "confidence_score": float(ultimate_decision.get("final_confidence", 0)),
                "risk_assessment": ultimate_decision.get("risk_level", "UNKNOWN"),
                "recommendation_strength": ultimate_decision.get("strength", "WEAK")
            }
        }

        # Ø¥Ø¶Ø§ÙØ© ØªØ­Ù„ÙŠÙ„ ÙˆØ§ÙŠÙƒÙˆÙ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ø§Ù‹
        if WYCKOFF_AVAILABLE and include_wyckoff and "error" not in wyckoff_result:
            result["analysis_layers"]["4_wyckoff_analysis"] = wyckoff_result

        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† numpy types Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
        cleaned_result = clean_response_data(result)
        return clean_response_data(response)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/price/{symbol}")
async def get_symbol_price(symbol: str):
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ø¹Ù…Ù„Ø© Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
    """
    try:
        # Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
        current_price = binance_client.get_symbol_price(symbol)
        if not current_price:
            raise HTTPException(status_code=404, detail=f"Symbol {symbol} not found")

        # Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„
        klines_data = binance_client.get_klines(symbol, "1h", 25)  # 24 Ø³Ø§Ø¹Ø© + Ø§Ù„Ø­Ø§Ù„ÙŠØ©

        price_info = {
            "symbol": symbol.upper(),
            "price": float(current_price),
            "timestamp": datetime.utcnow().isoformat(),
            "currency": "USDT"
        }

        if klines_data and len(klines_data) >= 2:
            # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØºÙŠÙŠØ± ÙÙŠ Ø§Ù„Ù€ 24 Ø³Ø§Ø¹Ø©
            current = float(klines_data[-1]["close"])
            previous_24h = float(klines_data[-25]["close"]) if len(klines_data) >= 25 else float(klines_data[0]["close"])

            price_change = current - previous_24h
            price_change_percent = (price_change / previous_24h) * 100

            # Ø­Ø³Ø§Ø¨ Ø£Ø¹Ù„Ù‰ ÙˆØ£Ø¯Ù†Ù‰ Ø³Ø¹Ø± ÙÙŠ 24 Ø³Ø§Ø¹Ø©
            highs = [float(candle["high"]) for candle in klines_data[-24:]]
            lows = [float(candle["low"]) for candle in klines_data[-24:]]
            volumes = [float(candle["volume"]) for candle in klines_data[-24:]]

            price_info.update({
                "change_24h": round(price_change, 4),
                "change_percent_24h": round(price_change_percent, 2),
                "high_24h": max(highs) if highs else current,
                "low_24h": min(lows) if lows else current,
                "volume_24h": sum(volumes) if volumes else 0,
                "market_status": determine_market_status(price_change_percent)
            })

        return clean_response_data(price_info)

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/symbols")
async def get_available_symbols():
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
    """
    try:
        symbols = binance_client.get_available_symbols()
        return {
            "symbols": symbols,
            "count": len(symbols),
            "note": "Popular USDT trading pairs"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/market/overview")
async def get_market_overview():
    """Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙˆÙ‚"""
    try:
        major_symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT", "XRPUSDT"]
        market_data = {}
        total_positive = 0
        total_symbols = 0

        for symbol in major_symbols:
            try:
                current_price = binance_client.get_symbol_price(symbol)
                if current_price:
                    klines = binance_client.get_klines(symbol, "1d", 2)
                    if klines and len(klines) >= 2:
                        current = float(klines[-1]["close"])
                        previous = float(klines[-2]["close"])
                        change_24h = ((current - previous) / previous) * 100

                        market_data[symbol] = {
                            "symbol": symbol,
                            "price": float(current_price),
                            "change_24h": round(change_24h, 2),
                            "volume": float(klines[-1]["volume"]),
                            "status": "UP" if change_24h > 0 else "DOWN" if change_24h < 0 else "NEUTRAL"
                        }

                        if change_24h > 0:
                            total_positive += 1
                        total_symbols += 1
            except Exception as e:
                continue

        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¹Ù†ÙˆÙŠØ§Øª
        positive_ratio = total_positive / total_symbols if total_symbols > 0 else 0

        if positive_ratio > 0.7:
            market_sentiment = "VERY_BULLISH"
        elif positive_ratio > 0.5:
            market_sentiment = "BULLISH"
        elif positive_ratio > 0.3:
            market_sentiment = "NEUTRAL"
        else:
            market_sentiment = "BEARISH"

        overview = {
            "market_sentiment": market_sentiment,
            "positive_ratio": round(positive_ratio * 100, 1),
            "total_symbols_analyzed": total_symbols,
            "symbols_up": total_positive,
            "symbols_down": total_symbols - total_positive,
            "market_data": market_data,
            "last_updated": datetime.utcnow().isoformat()
        }

        return clean_response_data(overview)

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Helper functions
def calculate_price_change_24h(klines_data):
    """Ø­Ø³Ø§Ø¨ ØªØºÙŠÙŠØ± Ø§Ù„Ø³Ø¹Ø± ÙÙŠ 24 Ø³Ø§Ø¹Ø©"""
    try:
        if len(klines_data) >= 25:
            current = float(klines_data[-1]["close"])
            previous = float(klines_data[-25]["close"])
            return round(((current - previous) / previous) * 100, 2)
        return 0
    except:
        return 0

def calculate_high_24h(klines_data):
    """Ø­Ø³Ø§Ø¨ Ø£Ø¹Ù„Ù‰ Ø³Ø¹Ø± ÙÙŠ 24 Ø³Ø§Ø¹Ø©"""
    try:
        if len(klines_data) >= 24:
            highs = [float(candle["high"]) for candle in klines_data[-24:]]
            return max(highs)
        return float(klines_data[-1]["high"]) if klines_data else 0
    except:
        return 0

def calculate_low_24h(klines_data):
    """Ø­Ø³Ø§Ø¨ Ø£Ø¯Ù†Ù‰ Ø³Ø¹Ø± ÙÙŠ 24 Ø³Ø§Ø¹Ø©"""
    try:
        if len(klines_data) >= 24:
            lows = [float(candle["low"]) for candle in klines_data[-24:]]
            return min(lows)
        return float(klines_data[-1]["low"]) if klines_data else 0
    except:
        return 0

def calculate_volume_24h(klines_data):
    """Ø­Ø³Ø§Ø¨ Ø­Ø¬Ù… Ø§Ù„ØªØ¯Ø§ÙˆÙ„ ÙÙŠ 24 Ø³Ø§Ø¹Ø©"""
    try:
        if len(klines_data) >= 24:
            volumes = [float(candle["volume"]) for candle in klines_data[-24:]]
            return sum(volumes)
        return float(klines_data[-1]["volume"]) if klines_data else 0
    except:
        return 0

def determine_market_status(change_percent):
    """ØªØ­Ø¯ÙŠØ¯ Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙˆÙ‚"""
    if change_percent > 5:
        return "STRONG_BULLISH"
    elif change_percent > 2:
        return "BULLISH"
    elif change_percent > -2:
        return "NEUTRAL"
    elif change_percent > -5:
        return "BEARISH"
    else:
        return "STRONG_BEARISH"

# Help endpoint for Enhanced Signals (only if available)
if ENHANCED_SIGNALS_AVAILABLE:
    @app.get("/trading/signals/help")
    async def get_enhanced_signals_help():
        """
        Ø¯Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†
        """
        return {
            "title": "Enhanced Trading Signals System v1.0",
            "description": "Ù†Ø¸Ø§Ù… Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ø­Ø³Ù† Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù… ÙˆÙ…Ø¤Ø´Ø±Ø§Øª Ø°ÙƒÙŠØ©",
            "status": "Available",
            "endpoints": {
                "enhanced_signals": {
                    "url": "/trading/signals/enhanced/{symbol}",
                    "description": "Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø´Ø§Ø±Ø§Øª ØªØ¯Ø§ÙˆÙ„ Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù…",
                    "parameters": {
                        "symbol": "Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø© (Ù…Ø«Ù„ BTCUSDT)",
                        "timeframe": "Ø§Ù„Ø¥Ø·Ø§Ø± Ø§Ù„Ø²Ù…Ù†ÙŠ (1m, 5m, 15m, 1h, 4h, 1d)",
                        "signal_strength": "Ù‚ÙˆØ© Ø§Ù„Ø¥Ø´Ø§Ø±Ø© (strong, medium, weak, all)"
                    },
                    "example": "/trading/signals/enhanced/BTCUSDT?timeframe=1h&signal_strength=strong"
                },
                "compare_signals": {
                    "url": "/trading/signals/compare/{symbol}",
                    "description": "Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø¹Ø¨Ø± Ø£Ø·Ø± Ø²Ù…Ù†ÙŠØ© Ù…ØªØ¹Ø¯Ø¯Ø©",
                    "parameters": {
                        "symbol": "Ø±Ù…Ø² Ø§Ù„Ø¹Ù…Ù„Ø©",
                        "timeframes": "Ø£Ø·Ø± Ø²Ù…Ù†ÙŠØ© Ù…ÙØµÙˆÙ„Ø© Ø¨ÙØ§ØµÙ„Ø©"
                    },
                    "example": "/trading/signals/compare/ETHUSDT?timeframes=1h,4h,1d"
                },
                "signals_summary": {
                    "url": "/trading/signals/summary/{symbol}",
                    "description": "Ù…Ù„Ø®Øµ Ø³Ø±ÙŠØ¹ Ù„Ù„Ø¥Ø´Ø§Ø±Ø§Øª - Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯",
                    "example": "/trading/signals/summary/BTCUSDT?timeframe=1h"
                },
                "watchlist_signals": {
                    "url": "/trading/signals/watchlist",
                    "description": "Ø¥Ø´Ø§Ø±Ø§Øª Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù„Ø¹Ø¯Ø© Ø¹Ù…Ù„Ø§Øª",
                    "parameters": {
                        "symbols": "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ù…ÙØµÙˆÙ„Ø© Ø¨ÙØ§ØµÙ„Ø©",
                        "timeframe": "Ø§Ù„Ø¥Ø·Ø§Ø± Ø§Ù„Ø²Ù…Ù†ÙŠ",
                        "min_confidence": "Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø«Ù‚Ø©"
                    },
                    "example": "/trading/signals/watchlist?symbols=BTCUSDT,ETHUSDT&min_confidence=70"
                }
            },
            "features": [
                "Enhanced RSI signals with volume confirmation",
                "Advanced MACD analysis with histogram trends",
                "Bollinger Bands squeeze detection for breakouts",
                "Golden Cross and Death Cross identification",
                "High volume breakout and breakdown detection",
                "AI model predictions integration",
                "Multi-timeframe consensus analysis",
                "Market context and risk assessment",
                "Confidence-weighted signal aggregation",
                "Watchlist monitoring for multiple symbols"
            ]
        }
else:
    @app.get("/trading/signals/help")
    async def get_enhanced_signals_help():
        """
        Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­ÙˆÙ„ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù† (ØºÙŠØ± Ù…ØªØ§Ø­)
        """
        return {
            "title": "Enhanced Trading Signals System",
            "status": "Not Available",
            "message": "Enhanced trading signals module is not installed or configured",
            "available_alternatives": [
                "/analysis/{symbol} - Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„ Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠ",
                "/ai/ultimate-analysis/{symbol} - Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ",
                "/price/{symbol} - Ù„Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆØ§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©"
            ],
            "note": "Ù„ØªÙØ¹ÙŠÙ„ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†ØŒ ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ù„Ù enhanced_trading_signals.py"
        }

# API Documentation endpoint
@app.get("/docs/api")
async def get_api_documentation():
    """
    Ø¯Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… API
    """
    return {
        "title": "Trading AI Platform API Documentation",
        "version": "1.0.0",
        "description": "Ù…Ù†ØµØ© Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ - Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…Ø·ÙˆØ±",

        "modules_status": {
            "enhanced_signals": ENHANCED_SIGNALS_AVAILABLE,
            "wyckoff_analysis": WYCKOFF_AVAILABLE,
            "basic_analysis": True,
            "ai_predictions": True
        },

        "core_endpoints": {
            "health_check": {
                "url": "/health",
                "method": "GET",
                "description": "ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØ§Ù„Ø§ØªØµØ§Ù„Ø§Øª"
            },
            "symbol_price": {
                "url": "/price/{symbol}",
                "method": "GET",
                "description": "Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ Ù…Ø¹ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø³ÙˆÙ‚"
            },
            "comprehensive_analysis": {
                "url": "/analysis/{symbol}",
                "method": "GET",
                "description": "Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ Ø§Ù„Ø´Ø§Ù…Ù„",
                "parameters": ["symbol", "interval", "limit"]
            },
            "ultimate_ai_analysis": {
                "url": "/ai/ultimate-analysis/{symbol}",
                "method": "GET",
                "description": "Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„ Ø¨Ø¬Ù…ÙŠØ¹ Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ",
                "parameters": ["symbol", "interval", "include_wyckoff"]
            },
            "market_overview": {
                "url": "/market/overview",
                "method": "GET",
                "description": "Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙˆÙ‚"
            },
            "available_symbols": {
                "url": "/symbols",
                "method": "GET",
                "description": "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„ØªØ¯Ø§ÙˆÙ„"
            }
        },

        "enhanced_endpoints": {
            "available": ENHANCED_SIGNALS_AVAILABLE,
            "endpoints": [
                "/trading/signals/enhanced/{symbol}",
                "/trading/signals/compare/{symbol}",
                "/trading/signals/summary/{symbol}",
                "/trading/signals/watchlist",
                "/trading/signals/help"
            ] if ENHANCED_SIGNALS_AVAILABLE else [],
            "note": "Enhanced signals require enhanced_trading_signals module"
        },

        "wyckoff_endpoints": {
            "available": WYCKOFF_AVAILABLE,
            "endpoints": [
                "/analysis/wyckoff/{symbol}"
            ] if WYCKOFF_AVAILABLE else [],
            "note": "Wyckoff analysis requires wyckoff_analysis module"
        },

        "supported_symbols": [
            "BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT", "XRPUSDT",
            "DOTUSDT", "LINKUSDT", "LTCUSDT", "BCHUSDT", "XLMUSDT"
        ],

        "supported_timeframes": [
            "1m", "5m", "15m", "30m", "1h", "4h", "6h", "12h", "1d"
        ],

        "response_format": {
            "success": {
                "status_code": 200,
                "data_type": "JSON",
                "cleaned": "All numpy types converted to native Python types"
            },
            "error": {
                "status_code": "4xx/5xx",
                "format": {"detail": "error message"}
            }
        },

        "usage_examples": {
            "get_btc_analysis": "GET /analysis/BTCUSDT?interval=1h",
            "get_enhanced_signals": "GET /trading/signals/enhanced/ETHUSDT?timeframe=4h&signal_strength=strong",
            "compare_timeframes": "GET /trading/signals/compare/BTCUSDT?timeframes=1h,4h,1d",
            "market_watchlist": "GET /trading/signals/watchlist?symbols=BTCUSDT,ETHUSDT&min_confidence=70",
            "wyckoff_analysis": "GET /analysis/wyckoff/BTCUSDT?multi_timeframe=true"
        },

        "rate_limits": {
            "binance_api": "Depends on Binance limits",
            "internal_processing": "No specific limits",
            "recommendation": "Use caching for frequent requests"
        }
    }

if __name__ == "__main__":
    import uvicorn
    print("ğŸš€ Starting Trading AI Platform...")
    print(f"âœ… Enhanced Signals: {'Available' if ENHANCED_SIGNALS_AVAILABLE else 'Not Available'}")
    print(f"âœ… Wyckoff Analysis: {'Available' if WYCKOFF_AVAILABLE else 'Not Available'}")
    print("ğŸ“Š Basic Analysis: Available")
    print("ğŸ¤– AI Predictions: Available")
    print("ğŸŒ Server starting on http://0.0.0.0:8000")
    uvicorn.run(app, host="0.0.0.0", port=8000)ed_result

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„: {str(e)}")

def combine_recommendations(technical: Dict, simple_ai: Dict, advanced_ai: Dict, wyckoff: Dict = None) -> Dict[str, Any]:
    """
    Ø¯Ù…Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø·Ø¨Ù‚Ø§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„
    """
    try:
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª ÙˆØ§Ù„Ø«Ù‚Ø© Ù…Ù† ÙƒÙ„ Ø·Ø¨Ù‚Ø©
        tech_rec = technical.get("overall_recommendation", "HOLD")
        tech_conf = float(technical.get("confidence", 50))

        simple_rec = "HOLD"
        simple_conf = 50.0
        if "recommendation" in simple_ai and "error" not in simple_ai:
            simple_rec = simple_ai["recommendation"]
            simple_conf = float(simple_ai.get("confidence", 50))

        advanced_rec = "HOLD"
        advanced_conf = 50.0
        if "ensemble_prediction" in advanced_ai and "error" not in advanced_ai:
            adv_pred = advanced_ai["ensemble_prediction"]
            advanced_rec = adv_pred.get("recommendation", "HOLD")
            advanced_conf = float(adv_pred.get("confidence", 50))

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªÙˆØµÙŠØ© ÙˆØ§ÙŠÙƒÙˆÙ
        wyckoff_rec = "HOLD"
        wyckoff_conf = 50.0
        wyckoff_phase = "UNKNOWN"

        if wyckoff and "error" not in wyckoff and "trading_recommendation" in wyckoff:
            wyckoff_trading = wyckoff["trading_recommendation"]
            wyckoff_rec = wyckoff_trading.get("action", "HOLD")
            wyckoff_conf = float(wyckoff_trading.get("confidence", 50)) * 100  # ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ù†Ø³Ø¨Ø© Ù…Ø¦ÙˆÙŠØ©
            wyckoff_phase = wyckoff.get("current_phase", "UNKNOWN")

        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆØ²Ø§Ù† Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø«Ù‚Ø©
        total_weight = 0
        weighted_buy_score = 0
        weighted_sell_score = 0
        contributing_signals = 0

        # ÙˆØ²Ù† Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ
        tech_weight = tech_conf / 100
        if tech_rec in ['BUY', 'STRONG_BUY']:
            weighted_buy_score += tech_weight
        elif tech_rec in ['SELL', 'STRONG_SELL']:
            weighted_sell_score += tech_weight
        total_weight += tech_weight
        if tech_rec != 'HOLD':
            contributing_signals += 1

        # ÙˆØ²Ù† AI Ø§Ù„Ø¨Ø³ÙŠØ·
        simple_weight = simple_conf / 100 * 1.2  # ÙˆØ²Ù† Ø£Ø¹Ù„Ù‰ Ù„Ù„Ù€ AI
        if simple_rec in ['BUY', 'STRONG_BUY']:
            weighted_buy_score += simple_weight
        elif simple_rec in ['SELL', 'STRONG_SELL']:
            weighted_sell_score += simple_weight
        total_weight += simple_weight
        if simple_rec != 'HOLD':
            contributing_signals += 1

        # ÙˆØ²Ù† AI Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        advanced_weight = advanced_conf / 100 * 1.5  # Ø£Ø¹Ù„Ù‰ ÙˆØ²Ù† Ù„Ù„Ù€ AI Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
        if advanced_rec in ['BUY', 'STRONG_BUY']:
            weighted_buy_score += advanced_weight
        elif advanced_rec in ['SELL', 'STRONG_SELL']:
            weighted_sell_score += advanced_weight
        total_weight += advanced_weight
        if advanced_rec != 'HOLD':
            contributing_signals += 1

        # ÙˆØ²Ù† ÙˆØ§ÙŠÙƒÙˆÙ (Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ø§Ù‹)
        wyckoff_weight = 0
        if wyckoff and "error" not in wyckoff:
            wyckoff_weight = wyckoff_conf / 100 * 1.3  # ÙˆØ²Ù† Ø¹Ø§Ù„ÙŠ Ù„ØªØ­Ù„ÙŠÙ„ ÙˆØ§ÙŠÙƒÙˆÙ
            if wyckoff_rec in ['BUY', 'STRONG_BUY']:
                weighted_buy_score += wyckoff_weight
            elif wyckoff_rec in ['SELL', 'STRONG_SELL']:
                weighted_sell_score += wyckoff_weight
            total_weight += wyckoff_weight
            if wyckoff_rec != 'HOLD':
                contributing_signals += 1

        # Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙˆØµÙŠØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
        if total_weight == 0:
            final_recommendation = "HOLD"
            final_confidence = 50.0
            agreement_level = "NO_SIGNALS"
        else:
            buy_ratio = weighted_buy_score / total_weight
            sell_ratio = weighted_sell_score / total_weight

            if buy_ratio > sell_ratio and buy_ratio > 0.4:
                final_recommendation = "STRONG_BUY" if buy_ratio > 0.7 else "BUY"
                final_confidence = min(buy_ratio * 100 * 1.2, 95.0)
            elif sell_ratio > buy_ratio and sell_ratio > 0.4:
                final_recommendation = "STRONG_SELL" if sell_ratio > 0.7 else "SELL"
                final_confidence = min(sell_ratio * 100 * 1.2, 95.0)
            else:
                final_recommendation = "HOLD"
                final_confidence = 60.0

            # Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø§ØªÙØ§Ù‚
            if contributing_signals >= 3:
                agreement_level = "STRONG_CONSENSUS"
            elif contributing_signals >= 2:
                agreement_level = "MODERATE_CONSENSUS"
            elif contributing_signals == 1:
                agreement_level = "SINGLE_SIGNAL"
            else:
                agreement_level = "MIXED_SIGNALS"

        # ØªØ­Ø¯ÙŠØ¯ Ù‚ÙˆØ© Ø§Ù„ØªÙˆØµÙŠØ©
        if final_confidence > 80:
            strength = "VERY_STRONG"
        elif final_confidence > 65:
            strength = "STRONG"
        elif final_confidence > 50:
            strength = "MODERATE"
        else:
            strength = "WEAK"

        # ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø®Ø§Ø·Ø±
        if final_confidence > 75 and contributing_signals >= 2:
            risk_level = "LOW"
        elif final_confidence > 60:
            risk_level = "MODERATE"
        else:
            risk_level = "HIGH"

        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙØ³ÙŠØ±
        if contributing_signals == 0:
            reasoning = "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø´Ø§Ø±Ø§Øª ÙˆØ§Ø¶Ø­Ø© - Ù…Ù† Ø§Ù„Ø£ÙØ¶Ù„ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±"
        elif contributing_signals == 1:
            reasoning = f"Ø¥Ø´Ø§Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ØªØ´ÙŠØ± Ø¥Ù„Ù‰ {final_recommendation}"
        else:
            consensus_type = "Ù‚ÙˆÙŠ" if agreement_level == "STRONG_CONSENSUS" else "Ù…ØªÙˆØ³Ø·" if agreement_level == "MODERATE_CONSENSUS" else "Ø¬Ø²Ø¦ÙŠ"
            reasoning = f"Ø¥Ø¬Ù…Ø§Ø¹ {consensus_type} Ù…Ù† {contributing_signals} ØªØ­Ù„ÙŠÙ„ Ø¹Ù„Ù‰ {final_recommendation}"

        # Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ÙˆØ§ÙŠÙƒÙˆÙ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ØªØ§Ø­Ø©
        wyckoff_info = {}
        if wyckoff and "error" not in wyckoff:
            wyckoff_info = {
                "wyckoff_phase": wyckoff_phase,
                "wyckoff_recommendation": wyckoff_rec,
                "wyckoff_confidence": wyckoff_conf
            }

        return {
            "final_recommendation": final_recommendation,
            "final_confidence": round(final_confidence, 1),
            "reasoning": reasoning,
            "agreement_level": agreement_level,
            "risk_level": risk_level,
            "strength": strength,
            "contributing_signals": contributing_signals,
            "weight_distribution": {
                "technical": round(tech_weight / max(total_weight, 1), 1) if total_weight > 0 else 0,
                "simple_ai": round(simple_weight / max(total_weight, 1), 1) if total_weight > 0 else 0,
                "advanced_ai": round(advanced_weight / max(total_weight, 1), 1) if total_weight > 0 else 0,
                "wyckoff": round(wyckoff_weight / max(total_weight, 1), 1) if total_weight > 0 and wyckoff_weight > 0 else 0
            },
            **wyckoff_info
        }

    except Exception as e:
        return {
            "final_recommendation": "HOLD",
            "final_confidence": 50.0,
            "reasoning": f"Ø®Ø·Ø£ ÙÙŠ Ø¯Ù…Ø¬ Ø§Ù„ØªÙˆØµÙŠØ§Øª: {str(e)}",
            "agreement_level": "ERROR",
            "risk_level": "HIGH",
            "strength": "WEAK",
            "contributing_signals": 0,
            "error": str(e)
        }

# Enhanced Trading Signals Endpoints (only if module is available)
if ENHANCED_SIGNALS_AVAILABLE and enhanced_signals:

    @app.get("/trading/signals/enhanced/{symbol}")
    async def get_enhanced_trading_signals(
        symbol: str,
        timeframe: str = Query(default="1h", description="1m, 5m, 15m, 1h, 4h, 1d"),
        signal_strength: str = Query(default="all", description="strong, medium, weak, all")
    ):
        """
        Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù…
        """
        try:
            result = enhanced_signals.get_enhanced_trading_signals(
                symbol=symbol.upper(),
                timeframe=timeframe,
                signal_strength=signal_strength
            )

            if "error" in result:
                raise HTTPException(status_code=400, detail=result["error"])

            return clean_response_data(result)

        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

    @app.get("/trading/signals/compare/{symbol}")
    async def compare_trading_signals(
        symbol: str,
        timeframes: str = Query(default="1h,4h,1d", description="Comma-separated timeframes")
    ):
        """
        Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª Ø¹Ø¨Ø± Ø£Ø·Ø± Ø²Ù…Ù†ÙŠØ© Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø¤ÙŠØ© Ø´Ø§Ù…Ù„Ø©
        """
        try:
            timeframe_list = [tf.strip() for tf in timeframes.split(",")]
            comparison_results = {}

            for tf in timeframe_list:
                try:
                    result = enhanced_signals.get_enhanced_trading_signals(
                        symbol=symbol.upper(),
                        timeframe=tf,
                        signal_strength="medium"
                    )
                    comparison_results[tf] = result
                except Exception as e:
                    comparison_results[tf] = {"error": str(e)}

            # ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙˆØ§ÙÙ‚ Ø¨ÙŠÙ† Ø§Ù„Ø£Ø·Ø± Ø§Ù„Ø²Ù…Ù†ÙŠØ©
            consensus_analysis = analyze_timeframe_consensus(comparison_results)

            return clean_response_data({
                "symbol": symbol.upper(),
                "timeframe_analysis": comparison_results,
                "consensus": consensus_analysis,
                "generated_at": datetime.utcnow().isoformat()
            })

        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/trading/signals/summary/{symbol}")
    async def get_signals_summary(
        symbol: str,
        timeframe: str = Query(default="1h", description="Primary timeframe for analysis")
    ):
        """
        Ù…Ù„Ø®Øµ Ø³Ø±ÙŠØ¹ Ù„Ù„Ø¥Ø´Ø§Ø±Ø§Øª - Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Ø§Ù„Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯
        """
        try:
            result = enhanced_signals.get_enhanced_trading_signals(
                symbol=symbol.upper(),
                timeframe=timeframe,
                signal_strength="medium"
            )

            if "error" in result:
                raise HTTPException(status_code=400, detail=result["error"])

            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ù„Ø®Øµ
            overall = result.get("overall_assessment", {})
            market_ctx = result.get("market_context", {})
            signals = result.get("signals", [])

            # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø³Ø±ÙŠØ¹Ø©
            signal_types = {}
            for signal in signals:
                signal_type = signal.get("type", "UNKNOWN")
                if signal_type not in signal_types:
                    signal_types[signal_type] = 0
                signal_types[signal_type] += 1

            summary = {
                "symbol": symbol.upper(),
                "current_price": result.get("current_price", 0),
                "overall_signal": overall.get("overall_signal", "HOLD"),
                "confidence": overall.get("confidence", 50),
                "trend": market_ctx.get("trend", "SIDEWAYS"),
                "risk_level": market_ctx.get("risk_level", "MEDIUM"),
                "price_change_24h": market_ctx.get("price_change_24h", 0),
                "signal_counts": signal_types,
                "total_signals": len(signals),
                "strongest_signal": overall.get("strongest_signal", {}),
                "recommendation": overall.get("recommendation", "No clear signals"),
                "last_updated": result.get("timestamp")
            }

            return clean_response_data(summary)

        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/trading/signals/watchlist")
    async def get_watchlist_signals(
        symbols: str = Query(default="BTCUSDT,ETHUSDT,BNBUSDT,ADAUSDT,XRPUSDT",
                            description="Comma-separated list of symbols"),
        timeframe: str = Query(default="1h", description="Timeframe for analysis"),
        min_confidence: int = Query(default=70, description="Minimum confidence level")
    ):
        """
        Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø´Ø§Ø±Ø§Øª Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù„Ø¹Ø¯Ø© Ø¹Ù…Ù„Ø§Øª
        """
        try:
            symbol_list = [s.strip().upper() for s in symbols.split(",")]
            watchlist_signals = {}

            for symbol in symbol_list:
                try:
                    result = enhanced_signals.get_enhanced_trading_signals(
                        symbol=symbol,
                        timeframe=timeframe,
                        signal_strength="medium"
                    )

                    if "error" not in result:
                        overall = result.get("overall_assessment", {})
                        confidence = overall.get("confidence", 0)

                        # ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø«Ù‚Ø©
                        if confidence >= min_confidence:
                            watchlist_signals[symbol] = {
                                "signal": overall.get("overall_signal", "HOLD"),
                                "confidence": confidence,
                                "current_price": result.get("current_price", 0),
                                "trend": result.get("market_context", {}).get("trend", "SIDEWAYS"),
                                "signal_count": result.get("signal_count", 0),
                                "strongest_signal": overall.get("strongest_signal", {}).get("indicator", "NONE")
                            }

                except Exception as e:
                    watchlist_signals[symbol] = {"error": str(e)}

            # ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø«Ù‚Ø©
            sorted_signals = dict(sorted(
                watchlist_signals.items(),
                key=lambda x: x[1].get("confidence", 0) if "error" not in x[1] else 0,
                reverse=True
            ))

            # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¹Ø§Ù…Ø©
            valid_signals = {k: v for k, v in sorted_signals.items() if "error" not in v}
            buy_count = sum(1 for v in valid_signals.values() if v.get("signal") == "BUY")
            sell_count = sum(1 for v in valid_signals.values() if v.get("signal") == "SELL")

            return clean_response_data({
                "watchlist": sorted_signals,
                "summary": {
                    "total_symbols": len(symbol_list),
                    "signals_found": len(valid_signals),
                    "buy_signals": buy_count,
                    "sell_signals": sell_count,
                    "hold_signals": len(valid_signals) - buy_count - sell_count,
                    "min_confidence": min_confidence,
                    "timeframe": timeframe
                },
                "generated_at": datetime.utcnow().isoformat()
            })

        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

# Wyckoff Analysis Endpoints (only if module is available)
if WYCKOFF_AVAILABLE and wyckoff_integration:

    @app.get("/analysis/wyckoff/{symbol}")
    async def get_wyckoff_analysis(
        symbol: str,
        interval: str = Query(default="1h", description="Timeframe for analysis"),
        multi_timeframe: bool = Query(default=False, description="Multi-timeframe analysis")
    ):
        """
        ØªØ­Ù„ÙŠÙ„ ÙˆØ§ÙŠÙƒÙˆÙ Ø§Ù„Ø´Ø§Ù…Ù„
        """
        try:
            if multi_timeframe:
                result = wyckoff_integration.get_multi_timeframe_wyckoff(symbol)
            else:
                result = wyckoff_integration.get_wyckoff_analysis_for_symbol(symbol, interval)

            if "error" in result:
                raise HTTPException(status_code=400, detail=result["error"])

            return clean_response_data(result)

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ ÙˆØ§ÙŠÙƒÙˆÙ: {str(e)}")

@app.get("/analysis/{symbol}")
async def get_comprehensive_analysis(
    symbol: str,
    interval: str = Query(default="1h", description="Timeframe: 1m, 5m, 15m, 1h, 4h, 1d"),
    limit: int = Query(default=200, ge=100, le=500, description="Number of data points")
):
    """
    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„ Ù„Ù„Ø¹Ù…Ù„Ø©
    """
    try:
        # Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Binance
        klines_data = binance_client.get_klines(symbol, interval, limit)
        if not klines_data:
            raise HTTPException(status_code=404, detail=f"Could not fetch data for {symbol}")

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±
        close_prices = extract_close_prices(klines_data)

        # Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ø§Ù…Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
        analysis_result = comprehensive_analysis(close_prices)

        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¢Ø®Ø± Ø´Ù…Ø¹Ø©
        latest_candle = klines_data[-1]

        # Ø¥Ø¶Ø§ÙØ© ØªØ­Ù„ÙŠÙ„ Ù…Ø­Ø³Ù† Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆÙØ±Ø§Ù‹
        enhanced_analysis = {}
        if ENHANCED_SIGNALS_AVAILABLE and enhanced_signals:
            try:
                enhanced_result = enhanced_signals.get_enhanced_trading_signals(
                    symbol=symbol.upper(),
                    timeframe=interval,
                    signal_strength="all"
                )
                if "error" not in enhanced_result:
                    enhanced_analysis = {
                        "enhanced_signals": enhanced_result.get("signals", []),
                        "market_context": enhanced_result.get("market_context", {}),
                        "overall_assessment": enhanced_result.get("overall_assessment", {})
                    }
            except Exception as e:
                print(f"Enhanced analysis failed: {e}")

        response = {
            "symbol": symbol.upper(),
            "interval": interval,
            "data_points": len(close_prices),
            "current_price": latest_candle["close"],
            "volume": latest_candle["volume"],
            "last_update": pd.Timestamp.fromtimestamp(latest_candle["timestamp"]/1000).strftime("%Y-%m-%d %H:%M:%S UTC"),
            "comprehensive_analysis": clean_response_data(analysis_result),
            "enhanced_analysis": clean_response_data(enhanced_analysis),
            "price_change_24h": calculate_price_change_24h(klines_data),
            "high_24h": calculate_high_24h(klines_data),
            "low_24h": calculate_low_24h(klines_data),
            "volume_24h": calculate_volume_24h(klines_data)
        }

        return clean
