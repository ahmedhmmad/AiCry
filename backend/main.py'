from fastapi import FastAPI, HTTPException, Query
from sqlalchemy import create_engine, text
import redis
import os
import pandas as pd
from dotenv import load_dotenv
from indicators import calculate_macd, generate_sample_data
from binance_client import BinanceClient, extract_close_prices
from typing import List, Optional
from pydantic import BaseModel

load_dotenv()

app = FastAPI(title="Trading AI Platform", version="1.0.0")

# Database connection
DATABASE_URL = "postgresql://trading_user:trading_pass_2024@postgres:5432/trading_db"
engine = create_engine(DATABASE_URL)

# Redis connection  
redis_client = redis.Redis(host='redis', port=6379, decode_responses=True)

# Binance client
binance_client = BinanceClient()

class PriceData(BaseModel):
    prices: List[float]
    fast_period: Optional[int] = 12
    slow_period: Optional[int] = 26
    signal_period: Optional[int] = 9

@app.get("/")
async def root():
    return {
        "message": "Trading AI Platform API", 
        "status": "running",
        "features": [
            "Real-time data from Binance",
            "MACD Technical Analysis",
            "Multiple cryptocurrency support"
        ]
    }

@app.get("/health")
async def health_check():
    try:
        with engine.connect() as conn:
            result = conn.execute(text("SELECT 1"))
            db_status = "connected"
    except Exception as e:
        db_status = f"error: {str(e)}"
    
    try:
        redis_client.ping()
        redis_status = "connected"
    except Exception as e:
        redis_status = f"error: {str(e)}"
    
    # اختبار Binance API
    try:
        price = binance_client.get_symbol_price("BTCUSDT")
        binance_status = "connected" if price else "error"
    except Exception as e:
        binance_status = f"error: {str(e)}"
    
    return {
        "database": db_status,
        "redis": redis_status,
        "binance_api": binance_status,
        "api": "healthy"
    }

@app.get("/symbols")
async def get_available_symbols():
    """
    الحصول على قائمة العملات المتاحة
    """
    try:
        symbols = binance_client.get_available_symbols()
        return {
            "symbols": symbols,
            "count": len(symbols),
            "note": "Popular USDT trading pairs"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/price/{symbol}")
async def get_current_price(symbol: str):
    """
    الحصول على السعر الحالي لعملة
    """
    try:
        price = binance_client.get_symbol_price(symbol)
        if price is None:
            raise HTTPException(status_code=404, detail=f"Symbol {symbol} not found")
        
        return {
            "symbol": symbol.upper(),
            "price": price,
            "timestamp": int(pd.Timestamp.now().timestamp())
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/macd/{symbol}")
async def get_macd_analysis(
    symbol: str,
    interval: str = Query(default="1h", description="Timeframe: 1m, 5m, 15m, 1h, 4h, 1d"),
    limit: int = Query(default=100, ge=50, le=500, description="Number of data points")
):
    """
    تحليل MACD لعملة محددة مع بيانات حقيقية من Binance
    """
    try:
        # جلب البيانات من Binance
        klines_data = binance_client.get_klines(symbol, interval, limit)
        if not klines_data:
            raise HTTPException(status_code=404, detail=f"Could not fetch data for {symbol}")
        
        # استخراج أسعار الإغلاق
        close_prices = extract_close_prices(klines_data)
        
        # حساب MACD
        macd_result = calculate_macd(close_prices)
        
        # معلومات إضافية
        latest_candle = klines_data[-1]
        
        return {
            "symbol": symbol.upper(),
            "interval": interval,
            "data_points": len(close_prices),
            "current_price": latest_candle["close"],
            "price_change_24h": round(((latest_candle["close"] - klines_data[-24]["close"]) / klines_data[-24]["close"]) * 100, 2) if len(klines_data) >= 24 else None,
            "volume": latest_candle["volume"],
            "last_update": pd.Timestamp.fromtimestamp(latest_candle["timestamp"]/1000).strftime("%Y-%m-%d %H:%M:%S UTC"),
            "macd_analysis": macd_result
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/macd/sample")
async def get_sample_macd():
    """
    حساب MACD مع بيانات عينة للاختبار
    """
    try:
        sample_prices = generate_sample_data(50)
        macd_result = calculate_macd(sample_prices)
        
        return {
            "symbol": "SAMPLE",
            "data_points": len(sample_prices),
            "latest_price": sample_prices[-1],
            "macd_analysis": macd_result
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/macd/calculate")
async def calculate_macd_endpoint(data: PriceData):
    """
    حساب MACD لبيانات مخصصة
    """
    try:
        if len(data.prices) < data.slow_period:
            raise HTTPException(
                status_code=400, 
                detail=f"Need at least {data.slow_period} data points"
            )
        
        macd_result = calculate_macd(
            data.prices, 
            data.fast_period, 
            data.slow_period, 
            data.signal_period
        )
        
        return {
            "input_data_points": len(data.prices),
            "parameters": {
                "fast_period": data.fast_period,
                "slow_period": data.slow_period,
                "signal_period": data.signal_period
            },
            "macd_analysis": macd_result
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
